
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Nihon Sotsu Friendly League Cup Registration</title>
  <link rel="icon" href="/images/futbola-favicon.ico" type="image/x-icon">
  <style>
    body {
      font-family: Arial, sans-serif;
      background-image: url('/images/backgroundOrangeGradient.jpg');
      padding: 20px;
      margin: 0;
    }

    h1 {
      text-align: center;
    }

    h2 {
      text-align: center;
      color: #702963;
    }

    .game-card {
      background: white;
      border-top: 5px solid #ff5a5f;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .game-info p {
      margin: 6px 0;
      font-size: 15px;
    }

    .availability {
      margin: 10px 0;
      font-weight: bold;
      color: #ff5a5f;
    }

    .form-section input, .form-section select {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    .form-section button {
      width: 100%;
      padding: 10px;
      background-color: #ff0000;
      color: white;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
    }

    .form-section button:hover {
      background-color: #cc0000;
    }

    .player-list {
      margin-top: 10px;
    }

    .player-avatar {
      display: inline-block;
      margin: 4px;
      text-align: center;
    }

    .player-avatar img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #ff5a5f;
      object-fit: cover;
    }

    .player-avatar span {
      display: block;
      font-size: 12px;
      max-width: 60px;
      overflow-wrap: break-word;
    }

    /* ===== Player cards (Kojin Sanka) ===== */
    .player-list {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .player-card {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      text-decoration: none;
      color: inherit;
    }

    .player-card:hover {
      border-color: #ff5a5f;
    }

    .player-card .avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #ff5a5f;
      object-fit: cover;
      flex: 0 0 44px;
    }

    .player-card .info {
      display: flex;
      flex-direction: column;
      line-height: 1.2;
      min-width: 0;
    }

    .player-card .name {
      font-weight: 800;
      color: #0f172a;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-card .meta {
      font-size: 12px;
      color: #475569;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-card .meta strong {
      color: #702963;
    }

    #calendarGrid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;                      /* reduced from 10px */
      max-width: 100%;               /* allow full width use */
      margin: 0 auto 20px auto;
      padding: 5px 6px;
    }

    .calendar-box {
      background-color: white;
      color: black;
      text-align: center;
      padding: 6px 2px;              /* reduced from 12px 6px */
      border-radius: 6px;            /* slightly tighter */
      font-size: 12px;               /* one step down */
      font-weight: bold;
      border: 2px solid #ff0000;
      box-shadow: 1px 1px 4px rgba(0,0,0,0.05);
      transition: all 0.2s ease;
      cursor: pointer;
      min-width: 34px;               /* force narrow fit */
      height: 50px;                  /* consistent vertical fit */
      display: flex;                /* better layout */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      line-height: 1.1;
    }

    .calendar-box:hover {
      border-color: #702963;
    }

    .calendar-box.selected {
      border-color: #ff0000;
      background-color: #ffe5e5;
      color: #702963;
    }

    .calendar-box.available {
      border-color: #28a745;
    }

    .calendar-box.almost {
      border-color: #ffc107;
    }

    .calendar-box.full {
      border-color: #dc3545;
    }

    .calendar-box.nogame {
      opacity: 1;
      border: 2px solid black;
      color: #333;
    }

    .calendar-box.past {
      opacity: 0.4;
      background: #f6f6f6;
      border: 2px solid #bbb;
      cursor: default;
      color: #999;
    }

    .calendar-header {
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      margin-bottom: 8px;
      color: #702963;
    }
    #calendarGridWrapper {
      border: 2px solid #702963;
      border-radius: 10px;
      padding: 20px 10px;
      background: white;
      max-width: 640px;
      margin: 0 auto 30px auto;
      box-shadow: 0 3px 6px rgba(0,0,0,0.05);
    }

    #calendarGridWrapper {
      display: none !important;
    }

    /* ---- Support / WhatsApp row ---- */
.help-row{
  display:flex; align-items:center; gap:8px;
  margin:10px 0 6px; color:#334155; font-size:13px;
}
.wa-button{
  display:inline-flex; align-items:center; justify-content:center;
  width:34px; height:34px; border-radius:50%;
  background:#25D366; color:#fff; text-decoration:none;
  box-shadow:0 2px 4px rgba(0,0,0,.15);
}
.wa-button svg{ width:20px; height:20px; }

    /* ===== PITCH PREVIEW (upright) ===== */
.pitch-wrap{
  position:relative;
  width:100%;
  max-width:820px;
  margin:10px auto 14px auto;
  aspect-ratio:468/300;
  background:#2f8d3a url('/images/pitch-upright.png') center/cover no-repeat;
  border-radius:12px; overflow:hidden; box-shadow:inset 0 0 0 2px #e5ffe5;
}
.pv-pos{
  position:absolute; transform:translate(-50%,-50%);
  display:flex; flex-direction:column; align-items:center; gap:6px;
}
.pv-row{ display:flex; align-items:center; gap:0; }
.pv-item{ display:flex; flex-direction:column; align-items:center; margin-left:-10px; }
.pv-item:first-child{ margin-left:0; }
.pv-slot{
  width:44px; height:44px; border-radius:50%;
  border:3px solid rgba(0,0,0,.9);
  background:rgba(255,255,255,.25);
  overflow:hidden; display:grid; place-items:center;
}
.pv-slot.empty{ border-style:dashed; opacity:.65 }
.pv-slot img{ width:100%; height:100%; object-fit:cover }
.pv-name{
  font:700 9px/1.1 system-ui; color:#111; text-align:center;
  margin-top:2px; max-width:60px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.pv-label{
  color:#111;
  font:800 12px/1.1 system-ui;
  text-shadow:none;
  margin-top:0;             /* almost touching names */
  line-height:1.0;
  text-align:center;
}
/* üì± phones: make pitch taller vertically & avatars 20% smaller */
@media (max-width:600px){
  .pitch-wrap{
    max-width:100%;
    aspect-ratio: 468 / 420;   /* taller field */
    background-size: cover;
  }

  /* ‚Üì shrink avatars by 20 % */
  .pv-slot{
    width:28px;      /* was 34px */
    height:28px;     /* was 34px */
  }
  .pv-item{ margin-left:-6px; }

  .pv-name{
    font-size:8px;
    max-width:45px;
  }

  .pv-label{
    font-size:10px;
    margin-top:0;
  }
}

/* üì± extra-small (SE / zoomed displays): even taller */
@media (max-width:380px){
  .pitch-wrap{ aspect-ratio: 468 / 460; }
  .pv-slot{ width:26px; height:26px; }
  .pv-item{ margin-left:-5px; }
}

  </style>
</head>
<body>
<h1>Nihon Sotsu Friendly League Cup</h1>
<h2>JAD FC</h2>
<div id="logoutContainer" style="text-align: center; margin-bottom: 20px;"></div>
<div id="calendarGridWrapper">
  <div class="calendar-header" id="monthLabel"></div>
  <div id="calendarGrid"></div>
</div>

<div id="gameContainer"></div>

<a class="button" href="/"
  style="display: block; width: fit-content; margin: 40px auto 0; background-color: #ff0000; color: white; padding: 12px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; text-align: center;">
  ‚Üê Back to Homepage
</a>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.48.0/+esm';

const SUPABASE_URL = 'https://kdbqroxhypnadolcxxxc.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtkYnFyb3hoeXBuYWRvbGN4eHhjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3MjkwNzYsImV4cCI6MjA1NzMwNTA3Nn0.c7_RVxoFdJNqQ62R3t1emH2Wf4dSsQaunHsHmbQxOBA'; // trimmed for safety
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

const container = document.getElementById("gameContainer");
const DEFAULT_AVATAR = '/images/default-avatar.png';
const FIXED_GAME_ID = '2dccae18-f0b3-4d29-b664-a53f12758349';

let user = null;
try {
  const { data } = await supabase.auth.getUser();
  user = data?.user ?? null;
} catch (err) {
  console.error("Supabase auth not available on booking page:", err);
}

const logoutContainer = document.getElementById("logoutContainer");

if (user) {
  logoutContainer.innerHTML = `
    <button id="logoutBtn" style="
      background-color: #702963;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    ">üö™ Logout</button>
  `;

  document.getElementById("logoutBtn").addEventListener("click", async () => {
    await supabase.auth.signOut();
    location.reload(); // or window.location.href = "/"
  });
} else {
  logoutContainer.innerHTML = `
    <a href="/login.html" style="
      color: #702963;
      font-weight: bold;
      text-decoration: none;
      padding: 10px 20px;
      border: 2px solid #702963;
      border-radius: 5px;
      display: inline-block;
    ">üîê Log In</a>
  `;
}

const calendarGrid = document.getElementById("calendarGrid");
const todayDate = new Date();
todayDate.setHours(0, 0, 0, 0); 
const todayStr = `${todayDate.getFullYear()}-${String(todayDate.getMonth() + 1).padStart(2, '0')}-${String(todayDate.getDate()).padStart(2, '0')}`;

const start = new Date(todayDate);
start.setDate(start.getDate() - todayDate.getDay() - 6); // lock to previous Monday - 7
const end = new Date(start);
end.setDate(start.getDate() + 27); // 4 full weeks

const allDates = [];
for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
  allDates.push(new Date(d));
}

const MONTHS = [
  "January","February","March","April","May","June",
  "July","August","September","October","November","December"
];

function setMonthLabel(dateObj) {
  const el = document.getElementById("monthLabel");
  if (!el) return;
  el.textContent = `${MONTHS[dateObj.getMonth()]} ${dateObj.getFullYear()}`;
}

const { data: games, error } = await supabase
  .from("games")
  .select("*")
  .eq("id", FIXED_GAME_ID)
  .limit(1);

// üßÆ Count bookings only for the games shown in this calendar
const gameIds = games.map(g => g.id);
let bookingCountMap = {};

if (gameIds.length) {
  const { data: bookings, error } = await supabase
    .from("game_bookings")
    .select("id, game_id")
    .in("game_id", gameIds)   // only these games
    .limit(5000);             // avoid the default 1000-row cap

  if (error) {
    console.error("Error loading bookings for calendar:", error);
  } else {
    (bookings || []).forEach(b => {
      bookingCountMap[b.game_id] = (bookingCountMap[b.game_id] || 0) + 1;
    });
  }
}

/*console.log("üßÆ Booking Count Map:", bookingCountMap);

// (optional) keep your GAME STATUS DEBUG here, but now it will use bookingCountMap

console.log("üìä ---- GAME STATUS DEBUG ----");
games.forEach(g => {
  const filled = bookingCountMap[g.id] || 0;
  const max = g.max_players || 0;

  let status = "available";
  if (max > 0) {
    const ratio = filled / max;
    if (ratio >= 1) status = "FULL";
    else if (ratio >= 0.7) status = "LIMITED";
    else status = "AVAILABLE";
  }

  console.log(
    `üìå ${g.game_date} | ${g.start_time} | ${g.id}\n` +
    `   Max: ${max}, Booked: ${filled}, Status: ${status}`
  );
});
console.log("üìä ---- END DEBUG ----");*/

if (error) {
  container.innerHTML = "<p>Error loading games</p>";
  console.error(error);
} else {
    
// const calendar = document.getElementById("datePicker");
// calendar.addEventListener("change", () => {
//   const selected = calendar.value;
//   renderGames(selected);
//};

const premiumGames = games.filter(g => g.premium);
const datedGames = games.filter(g => !g.premium);
renderGames();

const gameMap = {};
games.forEach(g => {
  const date = g.game_date;
  if (!gameMap[date]) gameMap[date] = [];
  gameMap[date].push(g);
});

//renderCalendarGrid();

function renderCalendarGrid() {
  calendarGrid.innerHTML = "";
  setMonthLabel(todayDate);
  allDates.forEach(dateObj => {
    const dateStr = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}-${String(dateObj.getDate()).padStart(2, '0')}`;
    const weekday = dateObj.toLocaleDateString("en-MY", { weekday: 'short' });
    const dayNum = dateObj.getDate();
    const monthNum = dateObj.getMonth() + 1;

    const box = document.createElement("div");
    box.classList.add("calendar-box");

    const gameList = gameMap[dateStr] || [];
    const isPast = dateObj < todayDate;
    let statusClass = "nogame";

    // layout content
    box.innerHTML = `
      <div style="font-size: 11px; color: #702963;">${weekday}</div>
      <div style="font-size: 14px; font-weight: bold;">${dayNum}/${monthNum}</div>
      <div class="dot-container"></div>
    `;

    const dotContainer = box.querySelector('.dot-container');
    dotContainer.style.marginTop = "4px";
    dotContainer.style.display = "flex";
    dotContainer.style.justifyContent = "center";
    dotContainer.style.gap = "3px";

    gameList.forEach(g => {
      const filled = bookingCountMap[g.id] || 0;
      const max = g.max_players || 0;
      let dotColor = 'gray';

      if (max > 0) {
        const ratio = filled / max;
        if (ratio >= 1) dotColor = 'red';
        else if (ratio >= 0.7) dotColor = 'orange';
        else dotColor = 'green';
      }

      const dot = document.createElement("span");
      dot.style.width = "6px";
      dot.style.height = "6px";
      dot.style.borderRadius = "50%";
      dot.style.backgroundColor = dotColor;
      dot.style.display = "inline-block";

      dotContainer.appendChild(dot);
    });

/*    if (gameList.length > 0) {
    if (isPast) {
      box.style.border = "2px solid #cc0000"; // Red border = past w/ game
    } else {
      box.style.border = "2px solid black";   // Normal border
    }
  } else {
    box.style.border = "1px solid #ddd";       // No games
  }*/

    // class logic
    if (isPast && gameList.length > 0) {
      box.style.border = "2px solid #cc0000";
    }
    if (dateObj < todayDate) {
      box.classList.add("past");
    }

    
    if (gameList.length) {
      // If ANY game is full ‚Üí day is red
      if (gameList.some(g => (bookingCountMap[g.id] || 0) >= (g.max_players || 0))) {
        statusClass = "full";
      }
      // Else if ANY game >= 70% ‚Üí day is orange
      else if (gameList.some(g => {
        const filled = bookingCountMap[g.id] || 0;
        const max = g.max_players || 0;
        return max > 0 && (filled / max) >= 0.7;
      })) {
        statusClass = "almost";
      }
      // Otherwise ‚Üí green
      else {
        statusClass = "available";
      }
    }

    box.classList.add(statusClass);

    if (isPast && gameList.length > 0) {
      box.style.border = "2px solid #cc0000"; // Red border for past played days
    }

    box.classList.add(statusClass);

    if (dateObj < todayDate) {
      box.classList.add("past");
    }

    if (dateStr === todayStr) {
      box.classList.add("selected");
      setMonthLabel(dateObj); 
      //calendar.value = dateStr;
      renderGames(dateStr);
    }

    box.addEventListener("click", () => {
      document.querySelectorAll(".calendar-box").forEach(b => b.classList.remove("selected"));
      box.classList.add("selected");
      setMonthLabel(dateObj); 
      //calendar.value = dateStr;
      renderGames(dateStr);
    });

    calendarGrid.appendChild(box);
    
  });
}

// ---- pitch helpers (same layout spirit as Create Game) ----
function distribute(n, minX, maxX){
  if(n<=1) return [(minX+maxX)/2];
  const step=(maxX-minX)/(n-1);
  return Array.from({length:n},(_,i)=>minX+i*step);
}
// Use old CB spacing; widen LB/RB outwards.
function buildPitchNodesFromLimits(limits){
  const out=[]; const Y={F:26,M:50,D:74,GK:90};
  const get=k=> (limits?.[k]|0);
  const push=(prefix,slots,x1,x2,y)=>{
    const xs=distribute(slots,x1,x2);
    for(let i=0;i<slots;i++) out.push({ key:`${prefix}${slots>1?i+1:""}`, x:xs[i], y, playersPerPos:2 });
  };
  if(get('LW')) push('LW',1,16,32,Y.F);
  if(get('ST')) push('ST',1,46,54,Y.F);
  if(get('RW')) push('RW',1,68,84,Y.F);
  if(get('DM')) push('DM',1,42,58,Y.M+4);
  if(get('CM')){
  const cmCount = Math.min(Math.ceil(get('CM')/2), 3);
  push('CM', cmCount, 24,76,Y.M,2);      // was 28..72
}
  if(get('LB')) push('LB',1,8,20,Y.D);    // was (16,28)
  if(get('CB')) push('CB', Math.min((get('CB')/2)|0,2), 36,64,Y.D);
  if(get('RB')) push('RB',1,80,92,Y.D);   // was (72,84)
  if(get('GK')) push('GK',1,46,54,Y.GK);
  // show SUBs vertically outside top-right corner
// show SUBs vertically outside top-right corner (with metadata)
if (get('SUB')) {
  const subCount = Math.min(get('SUB'), 3);
  const yPositions = [20, 35, 50]; // vertical alignment
  for (let i = 0; i < subCount; i++) {
    out.push({
      key: `SUB${i+1}`,
      x: 96,
      y: yPositions[i],
      playersPerPos: 1,
      isSub: true,
      subIndex: i,     // which sub this node is (0..2)
      subCount         // total rendered sub nodes
    });
  }
}
  return out;
}
async function renderPitchForGame(game){
  const wrap = document.getElementById(`pitch-${game.id}`);
  if (!wrap) return;
  wrap.innerHTML = "";

  const limits = game.position_limits || null;
  if (!limits){ wrap.innerHTML = `<div style="padding:10px;text-align:center;color:#64748b">No position caps set.</div>`; return; }

  // gather bookings (avatar+name) by position
  const { data: rows } = await supabase
    .from("game_bookings")
    .select("position, jersey_name, user_id, profiles(avatar_url, jersey_name)")
    .eq("game_id", game.id);

  const byPos = {};
  (rows||[]).forEach(r=>{
    const key = r.position || 'SUB';
    const name = r.profiles?.jersey_name || r.jersey_name || 'Player';
    const avatar = r.profiles?.avatar_url || DEFAULT_AVATAR;
    (byPos[key] ||= []).push({ name, avatar, user_id: r.user_id });
  });

  const slots = buildPitchNodesFromLimits(limits);
  // advance-by-consumption map so CM1 uses [0..1], CM2 uses [2..3], etc.
const posCursor = {};  // key ‚Üí next start index

  slots.forEach((slot)=>{
    const node = document.createElement('div');
    node.className = 'pv-pos';
    node.style.left = slot.x + '%';
    node.style.top  = slot.y + '%';

    const row = document.createElement('div');
    row.className = 'pv-row';

// ensure unique mapping per numbered position (CB1 != CB2, CM1 != CM2)
const rawKey  = slot.key;                     // e.g., "CM1"
const baseKey = rawKey.replace(/[0-9]+$/, ''); // e.g., "CM"

// prefer exact key (CM1) if present; otherwise fall back to base (CM)
let taken = byPos[rawKey];
let cursorKey = rawKey;
if (!taken || !taken.length) {
  taken = byPos[baseKey] || [];
  cursorKey = baseKey;
}

// figure out where to start consuming for this group
let start = posCursor[cursorKey] || 0;

for (let i = 0; i < slot.playersPerPos; i++) {
  const item = document.createElement('div');
  item.className = 'pv-item';

  const s = document.createElement('div');
  s.className = 'pv-slot';

  // SUB nodes use fixed index per stack; others consume sequentially
  const player = (baseKey === 'SUB' && slot.playersPerPos === 1)
    ? taken[slot.subIndex]
    : taken[start + i];

  if (player && player.avatar) {
    const img = document.createElement('img');
    img.src = player.avatar;
    img.onerror = () => { img.src = DEFAULT_AVATAR; };
    s.appendChild(img);
  } else {
    s.classList.add('empty');
  }

  item.appendChild(s);

  const nm = document.createElement('div');
  nm.className = 'pv-name';
  nm.textContent = player ? (player.name || 'Player') : '‚Äî';
  item.appendChild(nm);

  row.appendChild(item);
}

// advance consumption for this group (SUB handled by subIndex already)
if (baseKey !== 'SUB') {
  posCursor[cursorKey] = start + slot.playersPerPos;
}

node.appendChild(row);

// label once for SUB (on the bottom), otherwise show rawKey (CM1/CM2)
const shouldLabel = !slot.isSub || slot.subIndex === (slot.subCount - 1);
if (shouldLabel) {
  const lbl = document.createElement('div');
  lbl.className = 'pv-label';
  lbl.textContent = slot.isSub ? 'SUB' : rawKey;
  node.appendChild(lbl);
}

    wrap.appendChild(node);
  });
}

async function renderTeamPitch(game, teamSide){
  const wrap = document.getElementById(`pitch-${game.id}-${teamSide}`);
  if (!wrap) return;
  wrap.innerHTML = "";

  const limits = game.position_limits || null;
  if (!limits){
    wrap.innerHTML = `<div style="padding:10px;text-align:center;color:#64748b">No position caps set.</div>`;
    return;
  }

  const { data: rows } = await supabase
    .from("game_bookings")
    .select("position, jersey_name, user_id, team_side, profiles(avatar_url, jersey_name)")
    .eq("game_id", game.id)
    .eq("team_side", teamSide);

  const byPos = {};
  (rows||[]).forEach(r=>{
    const key = (r.position || 'SUB').toUpperCase();
    const name = r.profiles?.jersey_name || r.jersey_name || 'Player';
    const avatar = r.profiles?.avatar_url || DEFAULT_AVATAR;
    (byPos[key] ||= []).push({ name, avatar, user_id: r.user_id });
  });

  const slots = buildPitchNodesFromLimits(limits);
  const posCursor = {};

  slots.forEach(slot=>{
    const node = document.createElement('div');
    node.className = 'pv-pos';
    node.style.left = slot.x + '%';
    node.style.top  = slot.y + '%';

    const row = document.createElement('div');
    row.className = 'pv-row';

    const rawKey  = slot.key;
    const baseKey = rawKey.replace(/[0-9]+$/,'');
    let taken = byPos[rawKey];
    let cursorKey = rawKey;
    if (!taken || !taken.length) {
      taken = byPos[baseKey] || [];
      cursorKey = baseKey;
    }
    let start = posCursor[cursorKey] || 0;

    for (let i=0; i<slot.playersPerPos; i++){
      const item = document.createElement('div'); item.className='pv-item';
      const s = document.createElement('div'); s.className='pv-slot';

      const player = (baseKey === 'SUB' && slot.playersPerPos === 1)
        ? taken[slot.subIndex]
        : taken[start + i];

      if (player && player.avatar){
        const img = document.createElement('img');
        img.src = player.avatar; img.onerror = () => { img.src = 'images/default-avatar.png'; };
        s.appendChild(img);
      } else {
        s.classList.add('empty');
      }

      item.appendChild(s);
      const nm = document.createElement('div'); nm.className='pv-name';
      nm.textContent = player ? (player.name || 'Player') : '‚Äî';
      item.appendChild(nm);
      row.appendChild(item);
    }

    if (baseKey !== 'SUB') posCursor[cursorKey] = start + slot.playersPerPos;

    node.appendChild(row);
    const labelOnce = !slot.isSub || slot.subIndex === (slot.subCount - 1);
    if (labelOnce) {
      const lbl = document.createElement('div'); lbl.className='pv-label';
      lbl.textContent = slot.isSub ? 'SUB' : rawKey;
      node.appendChild(lbl);
    }
    wrap.appendChild(node);
  });
}

function optimisticPlaceOnPitch(gameId, booking, hasTeams=false) {
  const teamSide = (booking?.team_side || 'A').toUpperCase();
  const wrapId = hasTeams ? `pitch-${gameId}-${teamSide}` : `pitch-${gameId}`;
  const wrap = document.getElementById(wrapId);
  if (!wrap) return;

  const avatar = booking?.profiles?.avatar_url || DEFAULT_AVATAR;
  const name   = booking?.profiles?.jersey_name || booking?.jersey_name || 'Player';
  const pos    = (booking?.position || '').toUpperCase();  // e.g., "CM", "CM1", "GK", "SUB"

  if (!pos) return;

  // helper: find all nodes whose label matches this position group
  const nodes = [...wrap.querySelectorAll('.pv-pos')].filter(n => {
    const label = n.querySelector('.pv-label')?.textContent?.trim().toUpperCase() || '';
    if (!label) return false;
    if (pos.startsWith('SUB')) return label === 'SUB';  // all subs share one label on last node
    if (/\d$/.test(pos))      return label === pos;     // exact match (CB1, CM2, ...)
    return label.startsWith(pos);                       // base role (CM -> CM1/CM2/‚Ä¶)
  });

  if (!nodes.length) return;

  // choose node:
  //  - for exact keys (CB1/CM2) use that node
  //  - for base keys (CM) pick the first node with an empty slot
  let targetNode = nodes[0];
  if (!/\d$/.test(pos) && !pos.startsWith('SUB')) {
    const withEmpty = nodes.find(n => n.querySelector('.pv-slot.empty'));
    if (withEmpty) targetNode = withEmpty;
  }

  // fill the first empty slot in that node
  const emptySlot = targetNode.querySelector('.pv-slot.empty');
  if (!emptySlot) return;

  emptySlot.classList.remove('empty');
  const img = document.createElement('img');
  img.src = avatar;
  img.onerror = () => { img.src = DEFAULT_AVATAR; };
  emptySlot.appendChild(img);

  // update/append the name (it sits in the .pv-item under the slot)
  const item = emptySlot.parentElement; // .pv-item
  let nm = item.querySelector('.pv-name');
  if (!nm) {
    nm = document.createElement('div');
    nm.className = 'pv-name';
    item.appendChild(nm);
  }
  nm.textContent = name;
}

//renderGames(today); box.textContent = dayLabel;

function renderGames(selectedDate = null) {
  // ---- position options helper (caps + remaining) ----
function buildPositionOptions(limits, counts) {
  const POS = ['GK','CB','LB','RB','DM','CM','LW','RW','ST','SUB'];
  if (!limits) return POS.map(p => `<option value="${p}">${p}</option>`).join('');
  return POS.filter(p => (limits[p]|0) > 0).map(p => {
    const cap = limits[p] | 0;
    const taken = (counts && counts[p]) ? counts[p] : 0;
    const remaining = Math.max(cap - taken, 0);
    const disabled = remaining <= 0 ? 'disabled' : '';
    return `<option value="${p}" ${disabled}>${p} (${taken}/${cap})</option>`;
  }).join('');
}
  container.innerHTML = "";

  const filtered = games; // always show the fixed game

  [...filtered, ...premiumGames].forEach(async (game) => {
    const startDateTime = new Date(`${game.game_date}T${game.start_time}`);
    const isPast = startDateTime < new Date();
    const div = document.createElement("div");
    div.className = "game-card";
// Simple WhatsApp help link (for support or cancellation)
const supportLink = "https://wa.me/60126210204?text=" + 
  encodeURIComponent("Hi Futbola! I need help with my booking or would like to cancel my slot.");

    div.innerHTML = `
      <div class="game-info">
        <p><strong>üìõ Title:</strong> ${game.session_title || 'Untitled'}</p>
        <p><strong>üßë Host:</strong> ${game.host_name || 'Host'}</p>

        <p><strong>üìç Venue:</strong> ${game.venue}</p>
        <p><strong>üìÖ Date:</strong> ${game.game_date}</p>
        <p><strong>üïí Time:</strong> ${game.start_time} ‚Äì ${game.end_time}</p>

        <p><strong>üì∂ Level:</strong> ${game.level || 'N/A'}</p>
        <p><strong>üßÆ Format:</strong> ${game.player_format || 'N/A'}</p>
        <p><strong>üèüÔ∏è Teams:</strong> ${game.teams || 'N/A'}</p>
        <p><strong>üïπÔ∏è Courts:</strong> ${game.courts || 'N/A'}</p>
        <p><strong>‚è±Ô∏è Minutes:</strong> ${game.minutes || 'N/A'} min</p>

        <p><strong>üí∞ Price:</strong> RM ${parseFloat(game.price || 0).toFixed(2)}</p>
        <p><strong>üí≥ Payment:</strong> ${formatPayment(game.payment_type) || 'Manual'}</p>
        ${game.premium ? `<p style="color:goldenrod;">‚≠ê Premium</p>` : ""}
        <p class="availability">Slots: loading...</p>
        <div class="help-row">
  <span>Having trouble booking or want to cancel? Reach us:</span>
  <a class="wa-button" href="${supportLink}" target="_blank" rel="noopener" aria-label="WhatsApp us">
    <!-- WhatsApp SVG icon -->
    <svg viewBox="0 0 32 32" fill="currentColor" aria-hidden="true">
      <path d="M19.11 17.02c-.29-.14-1.71-.84-1.98-.94-.27-.1-.47-.14-.67.14-.19.29-.77.94-.95 1.13-.17.19-.35.21-.64.07-.29-.14-1.23-.45-2.34-1.44-.86-.76-1.44-1.7-1.61-1.99-.17-.29-.02-.45.13-.6.14-.14.29-.35.43-.52.14-.17.19-.29.29-.48.1-.19.05-.36-.02-.5-.07-.14-.67-1.62-.92-2.21-.24-.58-.49-.5-.67-.5h-.57c-.19 0-.5.07-.76.36-.26.29-.99.97-.99 2.36s1.02 2.74 1.16 2.93c.14.19 2.01 3.07 4.87 4.31.68.29 1.21.46 1.62.59.68.22 1.29.19 1.77.12.54-.08 1.71-.7 1.95-1.37.24-.67.24-1.24.17-1.36-.07-.12-.26-.19-.55-.34zM16.02 4C9.93 4 4.98 8.95 4.98 15.04c0 2.18.63 4.2 1.73 5.91L6 28l7.21-1.89c1.63.9 3.5 1.41 5.49 1.41 6.09 0 11.04-4.95 11.04-11.04S22.11 4 16.02 4zm0 20.06c-1.86 0-3.59-.55-5.03-1.5l-.36-.23-4.29 1.13 1.14-4.18-.24-.37a9.1 9.1 0 0 1-1.42-4.86C5.82 9.47 10.07 5.2 15.99 5.2c4.53 0 8.28 3.19 9.16 7.43.17.8.26 1.62.26 2.44 0 5.92-4.27 10.98-9.39 10.98z"/>
    </svg>
  </a>
</div>

      ${ game.team_selection ? `
` : `` }

${ (game.game_type === 'football' && game.position_selection && game.team_selection) ? `
  <h4 style="margin:8px 0 4px;color:#0f172a;font-weight:800;">${game.team_a_name || 'Futbola A'} Lineup</h4>
  <div id="pitch-${game.id}-A" class="pitch-wrap" aria-label="Pitch A"></div>
  <h4 style="margin:12px 0 4px;color:#0f172a;font-weight:800;">${game.team_b_name || 'Futbola B'} Lineup</h4>
  <div id="pitch-${game.id}-B" class="pitch-wrap" aria-label="Pitch B"></div>
` : (game.game_type === 'football' && game.position_selection) ? `
  <div id="pitch-${game.id}" class="pitch-wrap" aria-label="Pitch"></div>
` : `` }

      </div>
      
    ${isPast ? `
      <p style="color:#999; font-size:14px; font-weight:bold; margin:10px 0;">üìÖ Past session</p>
    ` : `
      <form class="form-section" id="form-${game.id}">
        
        ${user ? `
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <div style="width: 10%; min-width: 30px;">
              <input type="checkbox" name="selfBooking" checked style="margin: 0;" />
            </div>
            <label style="margin: 0; font-size: 14px;">I am playing</label>
          </div>
          <div class="guest-fields" style="display: none;">
            <input name="jersey_name" placeholder="Enter name" />
            <input name="phone" placeholder="Enter phone number" type="tel" />
          </div>
        ` : `
          <input name="jersey_name" placeholder="Enter name" required />
          <input name="phone" placeholder="Enter phone number" type="tel" required />
        `}

<!-- ===== Kojin Sanka extra questionnaire ===== -->

<label style="font-weight:700;color:#702963;margin-top:10px">
  University graduated (Japan)
</label>
<input
  name="uni"
  placeholder="e.g. Waseda University"
  required
/>

<label style="font-weight:700;color:#702963;margin-top:8px">
  Graduation year
</label>
<select name="grad_year" required>
  <option value="" selected disabled>‚Äî Select graduation year ‚Äî</option>
  ${Array.from({ length: 2026 - 1980 + 1 }, (_, i) => 1980 + i)
    .map(y => `<option value="${y}">${y}</option>`)
    .join("")}
</select>

<label style="font-weight:700;color:#702963;margin-top:8px">
  Football level
</label>
<select name="football_level" required>
  <option value="" selected disabled>‚Äî Select ‚Äî</option>
  <option value="beginner">Beginner</option>
  <option value="casual">Casual</option>
  <option value="intermediate">Intermediate</option>
  <option value="competitive">Competitive</option>
</select>

<label style="font-weight:700;color:#702963;margin-top:8px">
  Stamina level
</label>
<select name="stamina_level" required>
  <option value="" selected disabled>‚Äî Select ‚Äî</option>
  <option value="low">Low</option>
  <option value="medium">Medium</option>
  <option value="high">High</option>
</select>

<label style="font-weight:700;color:#702963;margin-top:8px">
  Date of birth
</label>
<input name="dob" type="date" required />

<!-- ===== end questionnaire ===== -->

${ (game.game_type === 'football' && game.team_selection) ? `
  <div style="margin:8px 0;">
    <label style="font-weight:700;color:#702963;display:block;margin-bottom:6px">Pick your team</label>
    <select id="team-select-${game.id}" name="team_side" required style="width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:6px">
      <option value="" selected disabled>‚Äî Select your team ‚Äî</option>
      <option value="A">${game.team_a_name || 'Futbola A'}</option>
      <option value="B">${game.team_b_name || 'Futbola B'}</option>
    </select>
  </div>
` : `` }

        ${ (game.game_type === 'football' && game.position_selection) ? `
  <label style="font-weight:700;color:#702963;margin-top:8px">Position</label>
<select name="position" id="pos-${game.id}" required>
  <option value="" selected disabled>‚Äî Select your position ‚Äî</option>
</select>
  <div class="note" style="font-size:12px;color:#64748b;margin-top:6px">
    Positions are limited; full positions will be disabled.
  </div>
` : `` }
        <button type="submit">‚úÖ Book Now</button>
      </form>
    `}
      <div class="player-list" id="players-${game.id}"></div>
    `;
    container.appendChild(div);
    // -- build position options (football + position_selection) --
if (game.game_type === 'football' && game.position_selection) {
  const selectEl  = div.querySelector(`#pos-${game.id}`);
  const teamSel   = document.querySelector(`#team-select-${game.id}`); // dropdown we added
  const teamHint  = div.querySelector(`#team-hint-${game.id}`);

  async function refreshSelect() {
    if (!selectEl) return;

    // which team are we counting for?
    const team = (game.team_selection && teamSel) ? (teamSel.value || '') : '';

    // count bookings for THIS game and THIS team (if any)
    let counts = {};
    let q = supabase
      .from("game_bookings")
      .select("position")
      .eq("game_id", game.id);

    if (game.team_selection && team) {
      q = q.eq("team_side", team);
    }

    const { data: rows } = await q;
    (rows || []).forEach(r => {
      const k = (r.position || 'SUB').toUpperCase();
      counts[k] = (counts[k] || 0) + 1;
    });

    // update hint ("(Futbola A)" / "(Futbola B)")
    if (teamHint && game.team_selection) {
      const name = team === 'B' ? (game.team_b_name || 'Team B')
                                : (game.team_a_name || 'Team A');
      teamHint.textContent = team ? `(${name})` : '';
    }

    // rebuild options with per-team counts and a safe placeholder on top
    selectEl.innerHTML =
      `<option value="" selected disabled>‚Äî Select your position ‚Äî</option>` +
      buildPositionOptions(game.position_limits, counts);
  }

  // initial fill
  await refreshSelect();

  // re-fill when team changes
  if (game.team_selection && teamSel) {
    teamSel.addEventListener('change', () => { refreshSelect(); });
  }

  // render pitches (two when team selection is on)
  if (game.team_selection) {
    await renderTeamPitch(game, 'A');
    await renderTeamPitch(game, 'B');
  } else {
    await renderPitchForGame(game);
  }
}

// -- render pitch view (single or split by team) --
//if (game.game_type === 'football' && game.position_selection) {
//  if (game.team_selection) {
//    await renderTeamPitch(game, 'A');
//    await renderTeamPitch(game, 'B');
//  } else {
//    await renderPitchForGame(game);
//  }
// }

    // guest toggle
    if (user && !isPast) {
      const form = document.getElementById(`form-${game.id}`);
      if (form) {
        const checkbox = form.querySelector('input[name="selfBooking"]');
        const guestFields = form.querySelector('.guest-fields');
        if (checkbox && guestFields) {
          checkbox.addEventListener("change", () => {
            const showGuest = !checkbox.checked;
            guestFields.style.display = showGuest ? "block" : "none";
            guestFields.querySelectorAll("input").forEach(input => {
              input.required = showGuest;
            });
          });
        }
      }
    }

    // bind form submit
document.getElementById(`form-${game.id}`)?.addEventListener("submit", (e) => {
  e.preventDefault();

  const form = e.target;

  // ‚úÖ Only require name/phone if:
  // - user is NOT logged in, OR
  // - user is booking as guest (selfBooking unchecked)
  const isSelf = !!form.querySelector('input[name="selfBooking"]')?.checked;
  const requireNamePhone = !user || !isSelf;

  const ok = validateKojinSankaForm(form, { requireNamePhone });
  if (!ok) return;

  bookGame(game.id, form, game);
});

    // load players (optional: hook up game logic)
    loadPlayers(game.id, game.game_date);
  });
}
}

async function loadPlayers(gameId, gameDate) {
  const target = document.getElementById("players-" + gameId);
  const isPastGame = new Date(gameDate) < todayDate;

  const [{ data: bookings, error: bookingError }, { data: game, error: gameError }] = await Promise.all([
    //supabase.from("game_bookings").select("*").eq("game_id", gameId),
    supabase.from("game_bookings").select(`*,profiles (jersey_name, avatar_url)`).eq("game_id", gameId), //new
    supabase.from("games").select("max_players").eq("id", gameId).single()
  ]);

  if (bookingError || gameError || !bookings || !game) {
    target.innerHTML = "<p>Failed to load players</p>";
    return;
  }
  const count = bookings.length;

  const html = bookings.map(b => {
  const label = b.profiles?.jersey_name || b.jersey_name || 'Player';
  const avatarUrl = b.profiles?.avatar_url || b.avatar_url || DEFAULT_AVATAR;

  // ‚úÖ read from JSON column
  const uni = b.extra_info?.university_graduated || b.extra_info?.uni || '-';
  const gradYear = b.extra_info?.graduation_year || b.extra_info?.grad_year || '-';
  const position = (b.position || 'SUB').toUpperCase();
  const metaText = `${uni} ‚Ä¢ ${gradYear}`;

  // link only if user_id exists
  const wrapTagStart = b.user_id
    ? `<a href="/player-public.html?id=${b.user_id}" class="player-card">`
    : `<div class="player-card">`;

  const wrapTagEnd = b.user_id ? `</a>` : `</div>`;

  return `
    ${wrapTagStart}
      <img class="avatar"
           src="${avatarUrl}"
           onerror="this.onerror=null;this.src='${DEFAULT_AVATAR}';" />
      <div class="info">
        <div class="name">${label}</div>
        <div class="meta"><strong>Pos</strong>: ${position}</div>
        <div class="meta"><strong>Uni</strong>: ${uni}</div>
        <div class="meta"><strong>Grad</strong>: ${gradYear}</div>
      </div>
    ${wrapTagEnd}
  `;
}).join("");

  target.innerHTML = html;

  const parentCard = target.closest(".game-card");
  if (!parentCard) return;

  const countEl = parentCard.querySelector(".availability");

  if (countEl) {
    if (count >= game.max_players) {
      countEl.textContent = `‚ùå FULL (${count}/${game.max_players})`;
      countEl.style.color = "gray";

      // ‚úÖ only attempt to access form if it's a future game
      if (!isPastGame) {
        const form = parentCard.querySelector("form");
        if (form) {
          form.innerHTML = "<p style='color: gray; font-weight: bold;'>‚ö†Ô∏è Booking Full</p>";
        }
      }
    } else {
      countEl.textContent = isPastGame
        ? `üìÖ ${count} players joined`
        : `üë• ${count}/${game.max_players} slots filled`;
    }
  }
}

console.log(user?.user_metadata?.avatar_url);

function validateKojinSankaForm(form, { requireNamePhone = true } = {}) {
  const missing = [];

  const get = (name) => form.querySelector(`[name="${name}"]`);
  const val = (name) => (get(name)?.value || "").trim();

  // Always required for this event
  if (!val("uni")) missing.push("University graduated");
  if (!val("grad_year")) missing.push("Graduation year");
  if (!val("football_level")) missing.push("Football level");
  if (!val("stamina_level")) missing.push("Stamina level");
  if (!val("dob")) missing.push("Date of birth");
  if (!val("position")) missing.push("Position");

  // Name + phone (for safety, enforce too unless you intentionally autofill)
  if (requireNamePhone) {
    if (!val("jersey_name")) missing.push("Name");
    if (!val("phone")) missing.push("Phone number");
  }

  if (missing.length) {
    alert("Please complete the following before booking:\n- " + missing.join("\n- "));

    // focus the first missing field
    const first = missing[0];
    const map = {
      "University graduated": "uni",
      "Graduation year": "grad_year",
      "Football level": "football_level",
      "Stamina level": "stamina_level",
      "Date of birth": "dob",
      "Position": "position",
      "Name": "jersey_name",
      "Phone number": "phone"
    };
    const el = get(map[first]);
    if (el) el.focus();

    return false;
  }

  return true;
}

async function bookGame(gameId, form, game) {
  const submitButton = form.querySelector('button[type="submit"]');
  submitButton.disabled = true;
  submitButton.textContent = "‚è≥ Booking...";

  const selfBooking = form.selfBooking?.checked;
  const jersey_name = form.jersey_name?.value?.trim();
  const phone = form.phone?.value?.trim();

  // ===== Kojin Sanka extra questionnaire =====
const uni = form.uni?.value?.trim();
const grad_year = form.grad_year?.value;
const football_level = form.football_level?.value;
const stamina_level = form.stamina_level?.value;
const dob = form.dob?.value;

// validation (simple + clear)
if (!uni || !grad_year || !football_level || !stamina_level || !dob) {
  alert("Please complete all alumni information (university, graduation year, football level, stamina level, date of birth).");
  submitButton.disabled = false;
  submitButton.textContent = "‚úÖ Book Now";
  return;
}

const extra_info = {
  university_graduated: uni,
  graduation_year: Number(grad_year),
  football_level,
  stamina_level,
  date_of_birth: dob
};
// ===== end questionnaire =====

  // Guests must provide name + phone
  if (!user && (!jersey_name || !phone)) {
    alert("Please enter both jersey name and phone number.");
    submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
    return;
  }
  // User booking someone else must provide guest info
  if (user && !selfBooking && (!jersey_name || !phone)) {
    alert("Please enter guest name and phone.");
    submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
    return;
  }

  // ‚úÖ If logged-in self-book and no phone on file, ask once and save it
if (user && selfBooking) {
  // get phone from profiles first
  let profilePhone = null;
  try {
    const { data: prof } = await supabase
      .from("profiles")
      .select("phone")
      .eq("id", user.id)
      .single();
    profilePhone = prof?.phone || user.phone || user.user_metadata?.phone || null;
  } catch (e) {
    console.warn("Profile lookup failed", e);
  }

  if (!profilePhone) {
    const typed = prompt("Please enter your phone number to continue booking:");
    if (!typed) {
      alert("Phone number is required to book.");
      submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
      return;
    }
    const normalized = typed.replace(/\D/g, "");
    if (normalized.length < 9) {
      alert("That doesn't look like a valid phone number.");
      submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
      return;
    }
    // save to profiles for future bookings
    const { error: upErr } = await supabase
      .from("profiles")
      .update({ phone: normalized })
      .eq("id", user.id);
    if (upErr) {
      alert("Couldn't save your phone. Please update it in your profile.");
      submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
      return;
    }
    // use this number for the current booking too
    form.phone && (form.phone.value = normalized); // optional: fill the field if visible
  }
}

  // Require position for football position-based games
  let position = null;
  if (game && game.game_type === 'football' && game.position_selection) {
    position = form.position?.value || "";
    if (!position) {
      alert("Please select a position.");
      submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
      return;
    }
  }

// Require team ONLY for football with team_selection
let selectedTeam = "";
if (game?.game_type === 'football' && game?.team_selection) {
  selectedTeam = document.querySelector(`#team-select-${gameId}`)?.value || "";
  if (!selectedTeam) {
    alert("Please select your team.");
    submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
    return;
  }
}

  // Best-effort client-side cap check (team-aware; base position)
  try {
    if (game?.position_selection && position) {
      const caps = game.position_limits || {};
      const basePos = position.toUpperCase().replace(/[0-9]+$/, ''); // CM1 -> CM
      const cap = caps[basePos] | 0;

      if (cap > 0) {
        let q = supabase.from('game_bookings')
          .select('position, team_side')
          .eq('game_id', gameId);
        if (game?.game_type === 'football' && game?.team_selection && selectedTeam) {
          q = q.eq('team_side', selectedTeam.toUpperCase());
        }
        const { data: rows } = await q;
        const taken = (rows || []).filter(r =>
          (r.position || '').toUpperCase().replace(/[0-9]+$/, '') === basePos
        ).length;
        if (taken >= cap) {
          alert("That position is already full for the selected team. Please choose another.");
          submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
          return;
        }
      }
    }
  } catch (e) {
    // ignore precheck errors; server insert will still be attempted
  }

// Build insert payload (self-book pulls from profiles first)
let profileName = user?.user_metadata?.jersey_name || user?.user_metadata?.full_name || null;
let profilePhone = user?.phone || user?.user_metadata?.phone || null;
let profileAvatar = user?.user_metadata?.avatar_url || null;

if (selfBooking && user?.id) {
  try {
    const { data: prof } = await supabase
      .from('profiles')
      .select('jersey_name, phone, avatar_url')
      .eq('id', user.id)
      .single();
    if (prof) {
      profileName = prof.jersey_name || profileName;
      profilePhone = prof.phone || profilePhone;
      profileAvatar = prof.avatar_url || profileAvatar;
    }
  } catch (_) {}
}

// ‚úÖ If logged-in self-book and no jersey name on file, ask once and save it
if (user && selfBooking) {
  if (!profileName || !profileName.trim()) {
    const typedName = prompt("Please enter your jersey name (how it appears on the list):");
    if (!typedName) {
      alert("Name is required to book.");
      submitButton.disabled = false;
      submitButton.textContent = "‚úÖ Book Now";
      return;
    }
    const safeName = typedName.trim().slice(0, 30); // limit length a bit
    try {
      const { error: nameErr } = await supabase
        .from("profiles")
        .update({ jersey_name: safeName })
        .eq("id", user.id);
      if (nameErr) {
        alert("Couldn't save your name. Please update it in your profile.");
        submitButton.disabled = false;
        submitButton.textContent = "‚úÖ Book Now";
        return;
      }
      profileName = safeName;
      // optional: reflect in any visible field
      if (form.jersey_name) form.jersey_name.value = safeName;
    } catch (e) {
      console.warn("Save jersey name failed:", e);
    }
  }
}//new end

// mirror stable: include ids + avatar for self-booking
const payload = selfBooking ? {
  game_id: gameId,
  user_id: user?.id || null,
  booked_by_user_id: user?.id || null,
  position: position || null,
  jersey_name: profileName || null,
  phone: profilePhone || null,      // ‚Üê now filled from profiles/auth
  avatar_url: profileAvatar || null,
  extra_info
} : {
  game_id: gameId,
  user_id: null,
  booked_by_user_id: user?.id || null,
  position: position || null,
  jersey_name: jersey_name || null,
  phone: phone || null,
  extra_info
};

if (selectedTeam) payload.team_side = selectedTeam.toUpperCase(); // 'A' or 'B'
// ‚úÖ Prevent same phone number booking twice for same game
const finalPhone = payload.phone?.trim();
if (finalPhone) {
  try {
    const { data: existing } = await supabase
      .from("game_bookings")
      .select("id")
      .eq("game_id", gameId)
      .eq("phone", finalPhone)
      .limit(1);

    if (existing && existing.length > 0) {
      alert("This phone number has already been used to book this game.");
      submitButton.disabled = false;
      submitButton.textContent = "‚úÖ Book Now";
      return;
    }
  } catch (e) {
    console.warn("Duplicate phone check failed:", e);
  }
}
  // Insert
  const { data: newBooking, error } = await supabase
    .from("game_bookings")
    .insert([payload])
    .select("id, position, team_side, jersey_name, user_id, profiles(avatar_url, jersey_name)")
    .single();

  if (error) {
    alert("Booking failed: " + error.message);
    console.error(error);
    submitButton.disabled = false; submitButton.textContent = "‚úÖ Book Now";
    return;
  }

  // Optimistic paint on pitch (A/B if enabled)
  try { optimisticPlaceOnPitch(gameId, newBooking, !!game.team_selection); } catch {}

// ‚úÖ Booking success + optional WhatsApp group prompt
alert("Booking successful!");

// Fetch contact info for this game
try {
  const { data: gameDetails } = await supabase
    .from("games")
    .select("contact_method, contact_link")
    .eq("id", gameId)
    .single();

if (gameDetails?.contact_link) {
  const method = gameDetails.contact_method || "WhatsApp";
  let url = (gameDetails.contact_link || "").trim();

  // ensure https:// for links without protocol
  if (!/^https?:\/\//i.test(url)) url = "https://" + url;

  // ‚úÖ If it's a group invite link, switch to deep link (opens WA app directly)
  const match = url.match(/^https?:\/\/chat\.whatsapp\.com\/([A-Za-z0-9]+)/i);
  if (match) {
    url = `whatsapp://chat?code=${match[1]}`;
  }

  const confirmJoin = confirm(`‚úÖ Booking successful!\n\nOpen the ${method} group now?`);
  if (confirmJoin) {
    // Direct open ‚Äî this will trigger WhatsApp app instantly
    window.location.href = url;
  }
}
} catch (e) {
  console.warn("Failed to fetch contact link:", e);
}

// Refresh players + pitches
loadPlayers(gameId);
if (game?.game_type === 'football' && game.position_selection) {
  if (game.team_selection) {
    await renderTeamPitch(game, 'A');
    await renderTeamPitch(game, 'B');
  } else {
    await renderPitchForGame(game);
  }
}

form.reset();
submitButton.disabled = false;
submitButton.textContent = "‚úÖ Book Now";
}

function formatPayment(type) {
  switch (type) {
    case 'pay_on_court': return 'Pay on Court';
    case 'pay_full': return 'Full Payment';
    case 'pay_booking': return 'Booking Fee';
    case 'other': return 'Other';
    default: return type || 'Manual';
  }
}


</script>
</body>
</html>
